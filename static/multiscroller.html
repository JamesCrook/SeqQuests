<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SwissProt Multiscroller</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        
        .column {
            flex: 1;
            border-right: 1px solid #444;
            overflow: hidden;
            position: relative;
            background: #222;
        }
        
        .column:last-child {
            border-right: none;
        }
        
        .column-content {
            position: absolute;
            width: 100%;
            user-select: none;
            cursor: grab;
        }
        
        .column-content.dragging {
            cursor: grabbing;
        }
        
        .item {
            padding: 12px;
            border-bottom: 1px solid #333;
            transition: background-color 0.1s;
        }
        
        .item:hover {
            background: #2a2a2a;
        }
        
        .item.selected {
            background: #2a4a5a;
        }
        
        .id-range {
            font-size: 14px;
            font-weight: bold;
            color: #88ccff;
        }
        
        .id-and-name {
            font-size: 13px;
        }
        
        .protein-id {
            color: #ffaa88;
            font-weight: bold;
        }
        
        .protein-name {
            color: #aaddaa;
            margin-left: 8px;
        }
        
        .full-record {
            font-size: 11px;
            line-height: 1.4;
        }
        
        .record-header {
            color: #ffaa88;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .sequence {
            color: #cccccc;
            word-wrap: break-word;
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <script>
        // Seeded pseudo-random number generator
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }
            
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
            
            nextInt(min, max) {
                return Math.floor(this.next() * (max - min + 1)) + min;
            }
            
            choice(array) {
                return array[Math.floor(this.next() * array.length)];
            }
        }
        
        // SwissProt Tree Implementation
        class SwissProtTree {
            constructor() {
                this.levels = [
                    { name: 'id-range', render: this.renderIdRange.bind(this) },
                    { name: 'id-and-name', render: this.renderIdAndName.bind(this) },
                    { name: 'full-record', render: this.renderFullRecord.bind(this) }
                ];
                
                this.proteinNames = [
                    'Hemoglobin', 'Insulin', 'Collagen', 'Keratin', 'Actin',
                    'Myosin', 'Tubulin', 'Albumin', 'Immunoglobulin', 'Fibrinogen',
                    'Cytochrome', 'Catalase', 'Lysozyme', 'Pepsin', 'Trypsin'
                ];
                
                this.aminoAcids = 'ACDEFGHIKLMNPQRSTVWY';
            }
            
            // Level 0: ID Range (P10000-P10099, P10100-P10199, etc.)
            next(cursor, level) {
                if (level === 0) {
                    if (cursor === null) return { cursor: 0, data: { rangeStart: 10000 } };
                    if (cursor >= 999) return null;
                    return { cursor: cursor + 1, data: { rangeStart: (cursor + 1) * 100 + 10000 } };
                } else if (level === 1) {
                    const { rangeStart, offset } = cursor;
                    if (offset >= 99) return null;
                    const newOffset = offset + 1;
                    return { 
                        cursor: { rangeStart, offset: newOffset }, 
                        data: { id: rangeStart + newOffset } 
                    };
                } else if (level === 2) {
                    return null; // Full records don't have next
                }
            }
            
            prev(cursor, level) {
                if (level === 0) {
                    if (cursor === null || cursor === 0) return null;
                    return { cursor: cursor - 1, data: { rangeStart: (cursor - 1) * 100 + 10000 } };
                } else if (level === 1) {
                    const { rangeStart, offset } = cursor;
                    if (offset <= 0) return null;
                    const newOffset = offset - 1;
                    return { 
                        cursor: { rangeStart, offset: newOffset }, 
                        data: { id: rangeStart + newOffset } 
                    };
                } else if (level === 2) {
                    return null;
                }
            }
            
            descend(cursor, level) {
                if (level === 0) {
                    // From range to first ID in range
                    return { 
                        cursor: { rangeStart: cursor * 100 + 10000, offset: 0 }, 
                        data: { id: cursor * 100 + 10000 } 
                    };
                } else if (level === 1) {
                    // From ID to full record
                    return { 
                        cursor: cursor, 
                        data: { id: cursor.rangeStart + cursor.offset } 
                    };
                } else {
                    return null;
                }
            }
            
            renderIdRange(data) {
                const start = data.rangeStart;
                const end = start + 99;
                return `<div class="id-range">P${start.toString().padStart(5, '0')} - P${end.toString().padStart(5, '0')}</div>`;
            }
            
            renderIdAndName(data) {
                const id = data.id;
                const rng = new SeededRandom(id);
                const name = rng.choice(this.proteinNames);
                return `<div class="id-and-name"><span class="protein-id">P${id.toString().padStart(5, '0')}</span><span class="protein-name">${name}</span></div>`;
            }
            
            renderFullRecord(data) {
                const id = data.id;
                const rng = new SeededRandom(id);
                const name = rng.choice(this.proteinNames);
                const seqLength = rng.nextInt(100, 500);
                
                let sequence = '';
                for (let i = 0; i < seqLength; i++) {
                    sequence += this.aminoAcids[Math.floor(rng.next() * this.aminoAcids.length)];
                    if ((i + 1) % 60 === 0) sequence += '\n';
                }
                
                return `<div class="full-record">
                    <div class="record-header">P${id.toString().padStart(5, '0')} - ${name}</div>
                    <div class="sequence">${sequence}</div>
                </div>`;
            }
        }
        
        // Column class
        class Column {
            constructor(container, tree, level) {
                this.container = container;
                this.tree = tree;
                this.level = level;
                this.items = [];
                this.selectedIndices = []; // Changed to array for multiple selections
                
                this.element = document.createElement('div');
                this.element.className = 'column';
                this.container.appendChild(this.element);
                
                this.content = document.createElement('div');
                this.content.className = 'column-content';
                this.element.appendChild(this.content);
                
                this.scrollOffset = 0;
                this.isDragging = false;
                this.dragStartY = 0;
                this.dragStartOffset = 0;
                this.draggedIndex = -1;
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                this.content.addEventListener('mousedown', (e) => this.onMouseDown(e));
                document.addEventListener('mousemove', (e) => this.onMouseMove(e));
                document.addEventListener('mouseup', (e) => this.onMouseUp(e));
            }
            
            onMouseDown(e) {
                const itemElement = e.target.closest('.item');
                if (!itemElement) return;
                
                const index = parseInt(itemElement.dataset.index);
                this.selectItem(index);
                
                this.isDragging = true;
                this.draggedIndex = index;
                this.dragStartY = e.clientY;
                this.dragStartOffset = this.scrollOffset;
                this.content.classList.add('dragging');
                e.preventDefault();
            }
            
            onMouseMove(e) {
                if (!this.isDragging) return;
                
                const delta = e.clientY - this.dragStartY;
                this.scrollOffset = this.dragStartOffset + delta;
                
                // Check if we need to load more items
                this.ensureItemsCoverViewport();
                
                this.render();
                
                // Notify multiscroller of drag
                if (this.onDrag) {
                    this.onDrag(this.selectedIndices, delta);
                }
            }
            
            ensureItemsCoverViewport() {
                if (this.items.length === 0) return;
                
                const viewportHeight = this.element.offsetHeight;
                const BUFFER = 100; // Pixels of buffer
                const MAX_ITEMS_TO_ADD = 50; // Don't add too many at once
                
                // Calculate total height of all items
                let totalHeight = 0;
                this.items.forEach(item => totalHeight += item.height);
                
                // Check if we need items at the top (scrolled down, positive offset means content moved down)
                if (this.scrollOffset > BUFFER) {
                    // Need more items at the beginning
                    let firstCursor = this.items[0].cursor;
                    let newItems = [];
                    let addedHeight = 0;
                    
                    // Keep adding items until we have enough buffer
                    for (let count = 0; count < MAX_ITEMS_TO_ADD; count++) {
                        const result = this.tree.prev(firstCursor, this.level);
                        if (!result) break;
                        
                        // Measure this item
                        const tempDiv = document.createElement('div');
                        tempDiv.style.position = 'absolute';
                        tempDiv.style.visibility = 'hidden';
                        tempDiv.style.width = this.element.offsetWidth + 'px';
                        this.element.appendChild(tempDiv);
                        tempDiv.innerHTML = '<div class="item">' + this.tree.levels[this.level].render(result.data) + '</div>';
                        const height = tempDiv.firstChild.offsetHeight;
                        this.element.removeChild(tempDiv);
                        
                        newItems.unshift({ cursor: result.cursor, data: result.data, height: height });
                        addedHeight += height;
                        firstCursor = result.cursor;
                        
                        // Stop if we've added enough buffer
                        if (addedHeight > this.scrollOffset + viewportHeight) break;
                    }
                    
                    if (newItems.length > 0) {
                        // Adjust scroll offset to account for new items
                        this.scrollOffset -= addedHeight;
                        
                        // Adjust selected indices and dragged index
                        this.selectedIndices = this.selectedIndices.map(idx => idx + newItems.length);
                        if (this.draggedIndex >= 0) {
                            this.draggedIndex += newItems.length;
                        }
                        
                        this.items = [...newItems, ...this.items];
                        this.rebuildDOM(); // Rebuild since we added items
                    }
                }
                
                // Recalculate total height after potentially adding items at top
                totalHeight = 0;
                this.items.forEach(item => totalHeight += item.height);
                
                // Check if we need items at the bottom
                const bottomOfContent = this.scrollOffset + totalHeight;
                if (bottomOfContent < viewportHeight - BUFFER) {
                    // Need more items at the end
                    let lastCursor = this.items[this.items.length - 1].cursor;
                    let itemsAdded = 0;
                    
                    // Keep adding until we fill the viewport with buffer
                    for (let count = 0; count < MAX_ITEMS_TO_ADD; count++) {
                        const result = this.tree.next(lastCursor, this.level);
                        if (!result) break;
                        
                        // Measure this item
                        const tempDiv = document.createElement('div');
                        tempDiv.style.position = 'absolute';
                        tempDiv.style.visibility = 'hidden';
                        tempDiv.style.width = this.element.offsetWidth + 'px';
                        this.element.appendChild(tempDiv);
                        tempDiv.innerHTML = '<div class="item">' + this.tree.levels[this.level].render(result.data) + '</div>';
                        const height = tempDiv.firstChild.offsetHeight;
                        this.element.removeChild(tempDiv);
                        
                        this.items.push({ cursor: result.cursor, data: result.data, height: height });
                        totalHeight += height;
                        lastCursor = result.cursor;
                        itemsAdded++;
                        
                        // Stop if we've filled enough
                        const newBottom = this.scrollOffset + totalHeight;
                        if (newBottom > viewportHeight + viewportHeight) break; // Extra buffer
                    }
                    
                    if (itemsAdded > 0) {
                        this.rebuildDOM(); // Rebuild since we added items
                    }
                }
            }
            
            onMouseUp(e) {
                if (!this.isDragging) return;
                this.isDragging = false;
                this.content.classList.remove('dragging');
            }
            
            selectItem(index) {
                this.selectedIndices = [index];
                if (this.onSelect) {
                    this.onSelect(index);
                }
                this.render();
            }
            
            setSelectedIndices(indices) {
                this.selectedIndices = indices;
                this.render();
            }
            
            selectChildrenOf(parentCursor, parentLevel) {
                // Find all items that are children of the parent cursor
                let selectedIndices = [];
                
                if (parentLevel === 0) {
                    // Parent is a range, children are IDs in that range
                    const rangeStart = parentCursor * 100 + 10000;
                    const rangeEnd = rangeStart + 99;
                    
                    this.items.forEach((item, idx) => {
                        if (item.data.id >= rangeStart && item.data.id <= rangeEnd) {
                            selectedIndices.push(idx);
                        }
                    });
                } else if (parentLevel === 1) {
                    // Parent is an ID, child is the full record for that ID
                    const parentId = parentCursor.rangeStart + parentCursor.offset;
                    
                    this.items.forEach((item, idx) => {
                        if (item.data.id === parentId) {
                            selectedIndices.push(idx);
                        }
                    });
                }
                
                this.setSelectedIndices(selectedIndices);
            }
            
            populate(startCursor, direction = 'both') {
                this.items = [];
                
                // Determine batch size based on level
                let batchSize = 200; // Default for middle column
                if (this.level === 0) {
                    batchSize = 100; // Left column - ranges
                } else if (this.level === 2) {
                    batchSize = 300; // Right column - full records
                }
                
                // Populate backwards
                let cursor = startCursor;
                let backItems = [];
                for (let i = 0; i < batchSize / 2; i++) {
                    const result = this.tree.prev(cursor, this.level);
                    if (!result) break;
                    backItems.unshift({ cursor: result.cursor, data: result.data });
                    cursor = result.cursor;
                }
                
                // Add start item
                const startResult = startCursor !== null ? { cursor: startCursor, data: this.getCursorData(startCursor) } : this.tree.next(null, this.level);
                if (startResult) {
                    this.items = [...backItems, { cursor: startResult.cursor, data: startResult.data }];
                    cursor = startResult.cursor;
                    
                    // Populate forwards
                    for (let i = 0; i < batchSize / 2; i++) {
                        const result = this.tree.next(cursor, this.level);
                        if (!result) break;
                        this.items.push({ cursor: result.cursor, data: result.data });
                        cursor = result.cursor;
                    }
                }
                
                this.measureItems();
                this.render();
            }
            
            getCursorData(cursor) {
                if (this.level === 0) {
                    return { rangeStart: cursor * 100 + 10000 };
                } else if (this.level === 1) {
                    return { id: cursor.rangeStart + cursor.offset };
                } else {
                    return { id: cursor.rangeStart + cursor.offset };
                }
            }
            
            measureItems() {
                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.visibility = 'hidden';
                tempDiv.style.width = this.element.offsetWidth + 'px';
                this.element.appendChild(tempDiv);
                
                this.items.forEach((item, index) => {
                    tempDiv.innerHTML = '<div class="item">' + this.tree.levels[this.level].render(item.data) + '</div>';
                    item.height = tempDiv.firstChild.offsetHeight;
                });
                
                this.element.removeChild(tempDiv);
            }
            
            render() {
                // Check if we need to rebuild DOM
                const existingItems = this.content.querySelectorAll('.item');
                
                if (existingItems.length !== this.items.length) {
                    // Item count changed, rebuild
                    this.rebuildDOM();
                } else {
                    // Just update selections and transform
                    existingItems.forEach((itemDiv, index) => {
                        if (this.selectedIndices.includes(index)) {
                            itemDiv.classList.add('selected');
                        } else {
                            itemDiv.classList.remove('selected');
                        }
                    });
                }
                
                this.content.style.transform = `translateY(${this.scrollOffset}px)`;
            }
            
            rebuildDOM() {
                this.content.innerHTML = '';
                
                this.items.forEach((item, index) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'item';
                    if (this.selectedIndices.includes(index)) {
                        itemDiv.classList.add('selected');
                    }
                    itemDiv.dataset.index = index;
                    itemDiv.innerHTML = this.tree.levels[this.level].render(item.data);
                    this.content.appendChild(itemDiv);
                });
            }
            
            getSelectedBounds() {
                if (this.selectedIndices.length === 0) return null;
                
                // Calculate bounds for all selected items
                let minIndex = Math.min(...this.selectedIndices);
                let maxIndex = Math.max(...this.selectedIndices);
                
                let top = 0;
                for (let i = 0; i < minIndex; i++) {
                    top += this.items[i].height;
                }
                
                let bottom = top;
                for (let i = minIndex; i <= maxIndex; i++) {
                    bottom += this.items[i].height;
                }
                
                return {
                    top: top + this.scrollOffset,
                    bottom: bottom + this.scrollOffset,
                    height: bottom - top
                };
            }
            
            getDraggedItemBounds() {
                if (this.draggedIndex < 0) return null;
                
                let top = 0;
                for (let i = 0; i < this.draggedIndex; i++) {
                    top += this.items[i].height;
                }
                
                return {
                    top: top + this.scrollOffset,
                    bottom: top + this.items[this.draggedIndex].height + this.scrollOffset,
                    height: this.items[this.draggedIndex].height
                };
            }
            
            scrollToProportional(draggedBounds, viewportHeight) {
                const myBounds = this.getSelectedBounds();
                if (!myBounds || !draggedBounds) return;
                
                // Calculate what proportion of the dragged item is visible
                const draggedTop = draggedBounds.top;
                const draggedBottom = draggedBounds.bottom;
                const draggedHeight = draggedBounds.height;
                
                let proportion = 0;
                if (draggedBottom <= 0) {
                    proportion = 1; // Fully scrolled past top
                } else if (draggedTop >= viewportHeight) {
                    proportion = 0; // Fully scrolled past bottom
                } else if (draggedTop <= 0 && draggedBottom >= viewportHeight) {
                    // Item spans entire viewport
                    proportion = -draggedTop / (draggedHeight - viewportHeight);
                } else if (draggedTop < 0) {
                    proportion = 1 - (draggedBottom / draggedHeight);
                } else if (draggedBottom > viewportHeight) {
                    proportion = draggedTop / (viewportHeight - draggedHeight);
                } else {
                    // Fully visible
                    proportion = draggedTop / (viewportHeight - draggedHeight);
                }
                
                // Apply same proportion to this column's selection
                const myHeight = myBounds.height;
                const availableSpace = viewportHeight - myHeight;
                const targetTop = proportion * availableSpace;
                
                let currentTop = 0;
                const minIndex = Math.min(...this.selectedIndices);
                for (let i = 0; i < minIndex; i++) {
                    currentTop += this.items[i].height;
                }
                
                this.scrollOffset = targetTop - currentTop;
                this.render();
            }
        }
        
        // Multiscroller class
        class Multiscroller {
            constructor(container, tree) {
                this.container = container;
                this.tree = tree;
                this.columns = [];
                
                // Create columns for each level
                tree.levels.forEach((level, index) => {
                    const column = new Column(container, tree, index);
                    column.onSelect = (itemIndex) => this.onColumnSelect(index, itemIndex);
                    column.onDrag = (itemIndex, delta) => this.onColumnDrag(index);
                    this.columns.push(column);
                });
                
                // Initialize first column
                this.columns[0].populate(null);
            }
            
            onColumnSelect(columnIndex, itemIndex) {
                const column = this.columns[columnIndex];
                const selectedItem = column.items[itemIndex];
                
                // Cascade through all subsequent columns
                for (let nextLevel = columnIndex + 1; nextLevel < this.columns.length; nextLevel++) {
                    const prevColumn = this.columns[nextLevel - 1];
                    const nextColumn = this.columns[nextLevel];
                    
                    // Collect all cursors from selected items in previous column
                    let firstChildCursor = null;
                    let parentCursorsToSelect = [];
                    
                    prevColumn.selectedIndices.forEach(idx => {
                        const prevItem = prevColumn.items[idx];
                        if (prevItem) {
                            parentCursorsToSelect.push(prevItem.cursor);
                            if (!firstChildCursor) {
                                const descended = this.tree.descend(prevItem.cursor, nextLevel - 1);
                                if (descended) {
                                    firstChildCursor = descended.cursor;
                                }
                            }
                        }
                    });
                    
                    if (firstChildCursor) {
                        // Populate the next column
                        nextColumn.populate(firstChildCursor);
                        
                        // Now select all children of all parent cursors
                        let allSelectedIndices = [];
                        parentCursorsToSelect.forEach(parentCursor => {
                            if (nextLevel - 1 === 0) {
                                // Parent is a range
                                const rangeStart = parentCursor * 100 + 10000;
                                const rangeEnd = rangeStart + 99;
                                
                                nextColumn.items.forEach((item, idx) => {
                                    if (item.data.id >= rangeStart && item.data.id <= rangeEnd) {
                                        if (!allSelectedIndices.includes(idx)) {
                                            allSelectedIndices.push(idx);
                                        }
                                    }
                                });
                            } else if (nextLevel - 1 === 1) {
                                // Parent is an ID
                                const parentId = parentCursor.rangeStart + parentCursor.offset;
                                
                                nextColumn.items.forEach((item, idx) => {
                                    if (item.data.id === parentId) {
                                        if (!allSelectedIndices.includes(idx)) {
                                            allSelectedIndices.push(idx);
                                        }
                                    }
                                });
                            }
                        });
                        
                        allSelectedIndices.sort((a, b) => a - b);
                        nextColumn.setSelectedIndices(allSelectedIndices);
                    } else {
                        // No children, clear this column
                        nextColumn.items = [];
                        nextColumn.selectedIndices = [];
                        nextColumn.rebuildDOM();
                    }
                }
            }
            
            onColumnDrag(draggedColumnIndex) {
                const draggedColumn = this.columns[draggedColumnIndex];
                const bounds = draggedColumn.getDraggedItemBounds();
                const viewportHeight = draggedColumn.element.offsetHeight;
                
                // Ensure all columns have enough items to cover their viewports
                this.columns.forEach((column) => {
                    if (column.items.length > 0) {
                        column.ensureItemsCoverViewport();
                    }
                });
                
                // Sync all other columns with selections
                this.columns.forEach((column, index) => {
                    if (index !== draggedColumnIndex && column.selectedIndices.length > 0) {
                        column.scrollToProportional(bounds, viewportHeight);
                    }
                });
            }
        }
        
        // Initialize
        const tree = new SwissProtTree();
        const multiscroller = new Multiscroller(document.getElementById('container'), tree);
    </script>
</body>
</html>